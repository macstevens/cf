C Flat




Capabilities:
* Test that two different procedures produce the same result.  When they don't, analyze sub-procedures that should produce the same result, automatically narrowing down the area where they diverge.

* Test that two versions (DEBUG/RELEASE) of a program produce the same sequence of states -- zero in on divergence

* Test that two separate runs of same program produce the same sequence of states -- zero in on divergence

*Automatic Unit Test





Equivalent Functions
Equivalent Functions in different languages: English, C++, assembly, machine,
Drawings, diagrams, documentation -- explicitly related to other documentation and code
functions related to other functions-- cut, paste, & customize


auto-version control/delete queue

source code directory structure automatically managed
dependencies, equivalences, other relations -- automatically managed




auto-tuning
  Current C++ coding methodology requires fixing object sizes at compile time.  There is often a memory/performance trade-off determining number of bits used for an integer, and other pre-allocated objects.  Many other algorithm choices are pre-configured.  This could be tuned against the problem at hand.  A standard pre-configured dll could have the best default settings.  Several other pre-configured dll's could have other settings, easily swapped in.  Finally, if the runtime is too long, the auto-tuner could evaluate the slow spots and re-compile a special-purpose dll for the current problem.



semi-assertions, dynamic check enabling
  Some conditions are possible errors (warnings), some are always errors.  Some checks take too long to run to be enabled in every place they apply.  The programming/runtime environment should be able to disable and enable various checks to zero-in on problems when needed, and regulate the quantity and sequence of error messages presented to the user/programmer.


Competitive/Non-competitive,   Secret/Public,   for-profit/open-source
Programmers deserve compensation for their work.  Users should pay for benefit received.  True information, helpful programs, should be spread as broadly as possible.  A programmer, or engineer, or any worker, should not need the support of an entire corporation, with its inherent restrictions, to be compensated for his work.



Code Units, Compilation Units
  Currently code is stored in files.  Each file is compiled as a whole.  Instead, code should be managed by a database.  The function or smaller code block could be the basic unit.  These could be assembled into files and sent to the compiler.  For editing, similar grouping could be done.  Much unnecessary re-compilation is currently done for changes to comments or other dis-related sections of code.

Explicit temporary variables

Explicit sequence points

Explicit function calls
  -constructors
  -destructors
  -start-up functions
  -exception? ? goto
  -function sequence within boolean expression: 
    if ((A() && B()) || C())
    -> A(&boolA)
       (boolA) ?
          G(bool_if) :
          H(bool_if);
          ...

explicit state
  - often, state is implicit, indicated by the current call stack, or current sequence point.  There should be a way to explicitly record the state in variables that need not be present in release builds.

Strict C-flat
  no global variables
  no local variables
  no temporary variables
  all functions void
  function = class
  no embedded loops
  loop body = function
  goto!


constify, unconstify -- make a variable a const, after initialization or just for a certain section


auto- code organization

multiple views of single line of code:
  expanded to multiple lines
  various graphical representations



auto-learning common bugs
  As each bug is fixed, however small, the programmer can categorize the problem.  Maybe the problem was simply that the function was never implemented, or whatever.  Then the IDE starts to learn that un-implemented functions sometimes cause bugs and can start to flag them as warnings when user is debugging and searching for the cause of the bug
  


GUI
Ptolemy project, EECS, UC Berkeley
Hugo Andrade, National Instruments, hugo.andrade@ni.com





                        C FLAT

C Flat, also known as Factored C, is an extension of C++.

No global variables.
No local variables.
Only class member variables.
No member functions.
Only global functions of the form void F(X).
No operator overloading, in fact, no operators at all
No virtual functions
No inheritance
No other subtle tricks
Every function and class is a template




class Point
{
    mX, mY
}

SetX(p, x)
{
    assert(p.type == Point);

}




Development Cycle
1. Make feature request/test/assertion.  Enable/disable assertion(s).
2. Run test(s).  Use software.
3. Notice error/outpoint.  Record error.  Log bug.
4. Get more information.  Narrow area of investigation.  Go to step 1 or 5
5. Make change.  If situation matches some pattern, implement pattern solution.  Go to step 1 or 2.







Recognize duplicate or similar code.  When code changes, make assertion or suggestion that the corresponding similar code should change.



Not just pass/fail assertions.  Also, suggestions (of possible errors, or of things to try), warnings (possible errors), %certainty of error.  Capable of turning on or off assertions for a given time period or given situation.  Snooze button.


Automatically test the envelope of limits on input & output




Explicit object ownership
B b;
A *a = new A();
b owns a; // 'owns' is keyword

Compiler can detect memory leaks by un-owned pointers passing out of scope.

Garbage collection/memory defragmentation, etc. OK, but all explicit.







Minimal Assumptions/Occam's Razor
C flat has many layers of rules and restrictions.  At the bottom, anything goes -- no rules.  On top of this is a system that allows rules to be customized.  On top of this are more rules.  ... At the top is specific data.  The reason for this is that any particular language or programming style should not be outlawed unless there is a reason for prohibiting it.  There should be a way to clearly define freedoms and restrictions for the group and for the individual.






Preemptive Action
When the computer is not busy with assigned tasks, it does tasks it expects to be assigned -- all types of tasks






Alternate Functions
Multiple functions with equivalent or exactly equal results.  Computer can choose which to use, to optimize.  Also, functions or ways to get info on the efficiency (time & memory) of a function based on input data or no input data.





Alternative data representations.
File + zipped file + way to keep them in sync.
.obj files put together into various combinations of .dlls and static libs, so that minimal incremental re-compilation and linking is needed for the edit-compile-test cycle.




Firewalls/Watertight Chambers
Each program is divided into semi-independent sections that can be shut down, memory cleared, etc. with minimal effect on the rest of the program.  Each section may be sub-divided.  That way, when something crashes, the minimal amount of program has to be shut down.





Organizing Data In Blocks
Reason: parallel processing, split giant blocks of data into smaller blocks for processing by several processors
Ideas:
Each block has a revision number.  Bigger blocks may also have a time stamp giving when they were last updated.  Some blocks may have a lock.
Equivalent blocks: compressed version, indexed version
Comparison functions: compare blocks, merge blocks.
One block may contained a summarized version of many sub-blocks and pointers to those sub-blocks.


Prediction & Estimation
predict what major steps are coming up & and amount of time and CPU effort and memory and other resources are required.
When crashed and demanding user OK or specific choices, try to predict what future choices are to be made and whether user can approve of all at once or some group of choices at once.



No hidden functions & transformations.  In C++ "a=b;" might mean "a = ConvertBToA(b);"  All such transformations are viewable by expanding the current section of code into it's sub-parts.

No hidden parts of objects.  Virtual function table pointers, etc. are all viewable.




Convenience tends to kill modularity.  For example, deep in an algorithm, you want to pop up a message box with a warning.  So the algorithm now depends on the GUI.  To solve this, layers of interpreters could link the two together.  if (there is a GUI) then { pop open a message box:  Windows code: { .... }  Mac OSX code: { ... } default code: { ... }




method for naming and tracking strings and other sub-products through the system.  Sometimes, it's not clear where a message came from.  Need to trace back to the source for debugging.


reduce waste  (Ockham's Razor, Toyota Way)
  - waste during programming/debugging
  - waste in exchanging money beteen programmer and user
  - waste in reporting & fixing bugs
  - waste in documentation
  - waste in exchanging ideas  (non-disclosure agreements)





